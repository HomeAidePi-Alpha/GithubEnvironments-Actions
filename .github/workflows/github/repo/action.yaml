name: Create a GitHub Repo and populate code, create secrets, docs & wiki, test for quality and check standards
on:
  push:
    branches:
      - "main"

inputs:
  GITHUB_ORG_NAME:
    description: 'GitHub Organization Name'
    required: true
  GITHUB_REPO_BRANCH:
    description: 'GitHub Repo Branch Name usually "main" or  "master"'
    required: true
  GITHUB_USER_Name:
    description: 'GitHub User Name'
    required: true
  GITHUB_USER_EMAIL:
    description: 'GitHub Repo Email'
    required: true
  GITHUB_REPO_NAME:
    description: 'GitHub Repo Name'
    required: true
  GITHUB_REPO_DESCRIPTION:
    description: 'GitHub Repo Description'
    required: true
  GITHUB_REPO_FILES:
    description: 'GitHub Repo Files Directory'
    required: true
  GITHUB_REPO_URL:
    description: 'GitHub Repo URL to the .git'
    required: true
  GITHUB_REPO_TOKEN:
    description: 'GitHub Repo Token for Auth'
    required: true
  GITHUB_REPO_FILE_LIST:
    description: 'GitHub Repo File List'
    required: true
  TEAMS_WEBHOOK:
    description: 'ChatOps Webhook for Ms Teams Channel Connector'
    required: true
  MY_SECRET:
    description: 'Secret Env Variable you would like to store (will be abstracted away from consumer)'
    required: true

env:
  python-version: [ '2.x', '3.x', 'pypy-2.7', 'pypy-3.7', 'pypy-3.8' ]
  # will need to add/edit/remove api calls below based on changing the environments matrix
  environments: ['PreProd', 'Prod']
  python-architecture: 'x64'
  pulled-from-keyvault : 'secret'
  pulled-from-cyberark : 'secret-shh'
  pulled-from-sql : 'secret-donttell'
  pulled-from-blob : 'secret-psst'
  pulled-from-file : 'secret-hey'
  pulled-from-stream : 'secret-omg'
  pulled-from-queue : 'secret-didjahear'
  pulled-from-service : 'secret-dontask'
  pulled-from-http-webhook-ideal : 'secret-wonttell'
  pulled-from-env-even-better : 'no-secret-found'

runs:
    using: "composite"
    steps:
      # Checkout the repo
    - name: Check out Repo
      uses: actions/checkout@v3
    # Setup Python versions
    - name: Setup Python versions
      uses: actions/setup-python@v3
      with:
        # Semantic version range syntax or exact version of a Python version
        python-version: ${{ env.python-version }}
        # Optional - x64 or x86 architecture, defaults to x64
        architecture: ${{ env.python-architecture }}
    # Printing the current Python version & can perform python to perform file or src move operations in advance of repo creation
    - name: Display Python version & Execute python on the file list
      shell: bash
      run: | 
        python -c "import sys; print(sys.version)"
        python ${{ inputs.GITHUB_REPO_FILE_LIST }}
    # Create a new GitHub repo with gh and use git to push project files
    - name: Create new Github Repo and Push baseline files (any project type)
      shell: bash
      run: |
        git config --global user.name ${{ inputs.GITHUB_USER_NAME }}
        git config --global user.email ${{ inputs.GITHUB_USER_EMAIL }}
        git config --global init.defaultBranch ${{ inputs.GITHUB_REPO_BRANCH }}
        rm -rf .git/
        git init
        git remote add origin "https://${{ inputs.GITHUB_REPO_TOKEN}}@github.com/${{ inputs.GITHUB_ORG_NAME}}/${{ inputs.GITHUB_REPO_NAME}}.git"
        echo "${{ inputs.GITHUB_REPO_TOKEN}}" > .githubtoken
        gh auth login --with-token < .githubtoken
        gh repo create ${{ inputs.GITHUB_ORG_NAME}}/${{ inputs.GITHUB_REPO_NAME}} --public
        git add README.md
        git add docs
        git commit -m "initial alpha checkin"
        git push -f origin ${{ inputs.GITHUB_REPO_BRANCH }}
    # Here we will create environment(s) and push secrets using gh cli 
    # Basically from any source you want to populate and will be abstracted away from the consumer of the repo in one degree of separation 
    # Unless they are doing bad deeds with the keys such as writing them to console or external places the keys wont be logged or able to be observed (in the non quantum sense) 
    # Consider federating Cloud Provider(s) to Github to prevent even bad deeds from consumers as the secrets will only be exchanged between upper domains and not downstreams or middlemen    
    
    # PREPROD Env & Secrets (one abstraction away from consumer of downstream repo) 
    # two+ abstractions away from consumer of downstream repo if the upper consumers who ran this are also abstracted away N+1 level- name: Create Env & secrets for (${{ env.environments[0] }} 
      shell: bash
      # places the token in a temp file so its not handled long and is not communicated across pipes or interfaces
      run: |
        echo "${{ inputs.GITHUB_REPO_TOKEN}}" > .githubtoken
        gh auth login --with-token < .githubtoken
        gh api --method PUT -H "Accept: application/vnd.github.v3+json" /repos/${{ inputs.GITHUB_ORG_NAME}}/${{ inputs.GITHUB_REPO_NAME}}/environments/${{ env.environments[0]}}        
        gh secret set pulled_from_keyvault --body "${{ env.pulled-from-keyvault }}" --env ${{ env.environments[0]}}
        gh secret set pulled_from_cyberark --body "${{ env.pulled-from-cyberark }}" --env ${{ env.environments[0]}}
        gh secret set pulled_from_sql --body "${{ env.pulled-from-sql }}" --env ${{ env.environments[0]}}
        gh secret set pulled_from_blob --body "${{ env.pulled-from-blob }}" --env ${{ env.environments[0]}}
        gh secret set pulled_from_file --body "${{ env.pulled-from-file }}" --env ${{ env.environments[0]}}
        gh secret set pulled_from_stream --body "${{ env.pulled-from-strem }}" --env ${{ env.environments[0]}}
        gh secret set pulled_from_queue --body "${{ env.pulled-from-queue }}" --env ${{ env.environments[0]}}
        gh secret set pulled_from_service --body "${{ env.pulled-from-service }}" --env ${{ env.environments[0]}}
        gh secret set pulled_from_http_webhook --body "${{ env.pulled-from-http-webhook }}" --env ${{ env.environments[0]}}        
    # PROD Env & Secrets (one abstraction away from consumer of downstream repo) 
    # two+ abstractions away from consumer of downstream repo if the upper consumers who ran this are also abstracted away N+1 level
    - name: Create Env & secrets for (${{ env.environments[1] }} 
      shell: bash
      # places the token in a temp file so its not handled long and is not communicated across pipes or interfaces
      run: |
        echo "${{ inputs.GITHUB_REPO_TOKEN}}" > .githubtoken
        gh auth login --with-token < .githubtoken
        gh api --method PUT -H "Accept: application/vnd.github.v3+json" /repos/${{ inputs.GITHUB_ORG_NAME}}/${{ inputs.GITHUB_REPO_NAME}}/environments/${{ env.environments[0]}}        
        gh secret set super_secret_nplus_abstractions_away --body "${{ env.pulled-from-env-even-better }}" --env ${{ env.environments[1]}}
      # Paste secret value for the current repository in an interactive prompt
      # $ gh secret set MYSECRET
      # Read secret value from an environment variable
      #$ gh secret set MYSECRET --body "$ENV_VALUE"
      # Read secret value from a file
      #$ gh secret set MYSECRET < myfile.txt
      # Set secret for a deployment environment in the current repository
      #$ gh secret set MYSECRET --env myenvironment
      # Set organization-level secret visible to both public and private repositories
      #$ gh secret set MYSECRET --org myOrg --visibility all
      # Set organization-level secret visible to specific repositories
      #$ gh secret set MYSECRET --org myOrg --repos repo1,repo2,repo3
      # Set user-level secret for Codespaces
      #$ gh secret set MYSECRET --user
      # Set repository-level secret for Dependabot
      #$ gh secret set MYSECRET --app dependabot
      # Set multiple secrets imported from the ".env" file
      #$ gh secret set -f .env
    # Send Chat Ops notification
    - name: Send chat ops notification to teams
      uses: dhollerbach/actions.send-message-to-ms-teams@1.0.10
      with:
        webhook: ${{ inputs.TEAMS_WEBHOOK }}
        message: 'Deployment Completed for github: ${{ github.sha }}'
   